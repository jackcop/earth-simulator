from OpenGL.GL import *

import numpy as np
from glob import glob
from PIL import Image
Image.MAX_IMAGE_PIXELS = None #disable PIL preventing large image loading
import open3d as o3d
from datetime import datetime

#Each object corresponds to the vertex data for a satellite. This data is generated by the
#TiffImage class from image_handler.py and saved to a .npy file. That class also generates the
#texture coordinates for each satellite, which is handled by the Texture class.

class Object():
    def __init__(self, satellite : str) -> None:
        self.satellite = satellite

        if (glob(f'data/vertex_coords/{self.satellite}_indices.npy')):
            try:
                #load vertices from file
                self.vertices = np.load(f'data/vertex_coords/{self.satellite}_vertex_coords.npy')
                #reconstruct the mesh from the vertices
                self.indices = np.load(f'data/vertex_coords/{self.satellite}_indices.npy')

                self.length = len(self.indices)
            except:
                raise ValueError(f'Failed to load {self.satellite} vertex information.')
        else:
            Object._mesh_reconstruction(self.vertices.reshape(-1, 3))        
            np.save(f'data/vertex_coords/{self.satellite}_indices.npy', self.indices)

        self.image_textures = Texture(self.satellite, ['images/default_image.png'])
        self.tbos = self.image_textures.tbos
        self.textures = self.image_textures.textures
        self.texture_coords = self.image_textures.tile_tex_coords
        self.num_layers = self.image_textures.num_layers

        self._initialize_gl_vertex_data()
        
    def _mesh_reconstruction(points) -> None:
        # Create an Open3D point cloud
        point_cloud = o3d.geometry.PointCloud()
        point_cloud.points = o3d.utility.Vector3dVector(points)
        distances = point_cloud.compute_nearest_neighbor_distance()
        avg_dist = np.mean(distances)
        radius = 4 * avg_dist

        search_param = o3d.geometry.KDTreeSearchParamHybrid(radius=radius, max_nn=1)
        #estimate normals for the point cloud
        point_cloud.estimate_normals(search_param=search_param)

        #perform mesh reconstruction using the ball pivoting algorithm
        mesh = o3d.geometry.TriangleMesh.create_from_point_cloud_ball_pivoting(point_cloud, 
                                                o3d.utility.DoubleVector([radius, radius * 2]))

        indices = np.asarray(mesh.triangles).flatten()

        return mesh, indices
    
    def load_textures(self, files) -> None:
        print(files)
        self.image_textures = Texture(self.satellite, files)
        self.tbos = self.image_textures.tbos
        self.textures = self.image_textures.textures                #list of texture arrays for each tile
        self.texture_coords = self.image_textures.tile_tex_coords   #list of texture coordinates for each tile
        self.num_layers = self.image_textures.num_layers

    def _initialize_gl_vertex_data(self) -> None:
        vao = glGenVertexArrays(1)
        glBindVertexArray(vao)

        vbo = glGenBuffers(1)
        glBindBuffer(GL_ARRAY_BUFFER, vbo)
        glBufferData(GL_ARRAY_BUFFER, self.vertices, GL_STATIC_DRAW)

        ebo = glGenBuffers(1)
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo)
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, self.indices, GL_STATIC_DRAW)

        #position attribute
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, None)
        glEnableVertexAttribArray(0)

        glBindBuffer(GL_ARRAY_BUFFER, 0)
        glBindVertexArray(0)

        self.vao, self.vbo, self.ebo = vao, vbo, ebo

    def clear_images(self) -> None:
        self.image_textures.delete()
        self.tbos = []
        self.textures = []
        self.texture_coords = []
        self.num_layers = 0

    def delete(self) -> None:
        glDeleteVertexArrays(1, self.vao)
        glDeleteBuffers(1, self.vbo)
        glDeleteBuffers(1, self.ebo)
        self.image_textures.delete()

        del(self.vertices)
        del(self.indices)
    

#the Texture class should only use images selected by the user
#class to handle texture loading, binding, and tiling
class Texture():
    def __init__(self, satellite : str, files : list) -> None:
        self.satellite = satellite
        image_files = files
        
        if (len(image_files) > 1):
            self.images = self._get_timeseries_images(image_files)
        else:
            self.images = [Image.open(image_files[0])]

        self.num_layers = len(self.images)
        self.texture_coordinates = np.load(f'data/texture_coords/{self.satellite}_tex_coords.npy')
        self.max_size = glGetIntegerv(GL_MAX_TEXTURE_SIZE)

        self.slider_value = 0.0

        self._get_tiles()
        self._generate_tile_texture_data()
        self._generate_tile_coords()
        self._init_textures()
        self._generate_texture_buffers()

    #return a timeseries ordered list of Image objects 
    def _get_timeseries_images(self, image_files : list) -> list: #returns an ordered list of Image objects
        timestamp_format = '%Y%m%d_%H%M'
        timestamps = []

        for file in image_files:
            date_str = file.split('_')[-2:]
            date_str = str(date_str[0] + '_' + date_str[1]).split('.')[0]
            date = datetime.strptime(date_str, timestamp_format)
            timestamps.append(date)
        
        timestamps = sorted(timestamps)
        ts_str = [date.strftime(timestamp_format) for date in timestamps]
        image_files = [i for i in image_files for j in ts_str if j in i]

        return [Image.open(file) for file in image_files]

    def _generate_texture_buffers(self) -> None:
        tbos = []

        #A list of texture buffers for each tile. Will be identical for each timeseries image
        for i in range(self.num_tiles):
            tbo = glGenBuffers(1)
            glBindBuffer(GL_ARRAY_BUFFER, tbo)
            glBufferData(GL_ARRAY_BUFFER, self.tile_tex_coords[i], GL_STATIC_DRAW)
            glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, None)
            glEnableVertexAttribArray(1)
            tbos.append(tbo)
            glBindBuffer(GL_ARRAY_BUFFER, 0)

        self.tbos = tbos

    def _init_textures(self) -> None:
        all_textures = []
        
        #loop through each tile (same for all images) and create a texture for each layer
        for j in range(self.num_layers):
            layer_textures = []

            for i in range(self.num_tiles):
                texture = glGenTextures(1)
                glBindTexture(GL_TEXTURE_2D, texture)
                glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, self.tile_width, 
                            self.tile_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, np.asarray(self.tile_images[j][i]).flatten())
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE) #set texture wrapping parameters
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
                #set texture filtering parameters
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)

                layer_textures.append(texture)

            all_textures.append(layer_textures)

        self.textures = all_textures #[[layer1_tile1, layer1_tile2, ...], [layer2_tile1, layer2_tile2, ...]
            
    def _get_tiles(self) -> None:
        self.num_tiles_x = (self.images[0].width // self.max_size) + 1
        self.num_tiles_y = (self.images[0].height // self.max_size) + 1
        self.num_tiles = self.num_tiles_x * self.num_tiles_y
        self.tile_width = self.images[0].width // self.num_tiles_x
        self.tile_height = self.images[0].height // self.num_tiles_y

    def _generate_tile_texture_data(self) -> None:
        #for each tile, create a new image and save it to a list
        timeseries_tile_images = [] #list of lists of images [ts1_tiles, ts2_tiles, ...]
        tile_images = []

        if self.num_tiles > 1:
            for image in self.images:
                x_offsets = [x * self.tile_width for x in range(self.num_tiles_x)] #x offsets for each tile
                y_offsets = [y * self.tile_height for y in range(self.num_tiles_y)] #y offsets for each tile
                #we need an array of length num_tiles_x * num_tiles_y, where each element is a tuple of (x, y) offsets
                #       _______
                #order |_1_|_3_|
                #      |_2_|_4_|

                combined = [(x, y) for x in x_offsets for y in y_offsets]
                tile_images = [image.crop((x, y, x + self.tile_width, y + self.tile_height)) for x, y in combined]
                timeseries_tile_images.append(tile_images)
        else:
            timeseries_tile_images = [[image] for image in self.images]
        
        self.tile_images = timeseries_tile_images

    def _generate_tile_coords(self) -> None:
        tile_tex_coords = [] #texture coordinates for each tile
        tex_coords = self.texture_coordinates.reshape(-1, 2)
        #for each tile in the image, we must define new texture coordinates by 
        #scaling the original texture coordinates by the tile width and height
        #and then translating them by the tile's x and y position
        #       _______
        #order |_1_|_3_|
        #      |_2_|_4_|

        for x in range(0, self.num_tiles_x):
            for y in range(0, self.num_tiles_y):
                x_offset = (x * self.tile_width) / self.images[0].width
                y_offset = (y * self.tile_height) / self.images[0].height
                x_scale = self.tile_width / self.images[0].width
                y_scale = self.tile_height / self.images[0].height

                #scale the texture coordinates and then translate them
                tile_coords = np.column_stack((tex_coords[:, 0] - x_offset, tex_coords[:, 1] - y_offset))
                tile_coords = np.column_stack((tile_coords[:, 0] / x_scale, tile_coords[:, 1] / y_scale))

                tile_tex_coords.append(tile_coords.flatten())
                #print the length of tile_coords that are inside the range 0-1

        self.tile_tex_coords = tile_tex_coords

    def delete(self) -> None:
        [glDeleteTextures(1, texture) for layer in self.textures for texture in layer]
        #clear buffers
        [glDeleteBuffers(1, tbo) for tbo in self.tbos]
        #clear images
        del(self.tile_images)
        del(self.images)
